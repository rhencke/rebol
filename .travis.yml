#
# .travis.yml contains YAML-formatted (http://www.yaml.org/) instructions
# for building Rebol for continuous integration via Travis CI:
#
# http://docs.travis-ci.com/
#
# Several platforms and compilers are used to try and give a breadth of
# testing for portability.  Also if the build process is successful with no
# errors, then the resulting binaries are deployed to an S3 instance:
#
# https://docs.travis-ci.com/user/deployment/s3/
#
# Those files are indexed by a Rebol script to generate an HTML download page.
# The generation is currently run manually when interesting new versions are
# available, and published here:
#
# http://metaeducation.s3.amazonaws.com/index.html
#

# Note: "The suggested syntax for YAML files is to use 2 spaces for
# indentation, but YAML will follow whatever indentation system that the
# individual file uses."
#
# http://yaml.org/spec/1.2/spec.html#id2777534
#
# For this file, follow the convention that list items (started with dash)
# are indented two spaces from their container key, and then all members of
# the list are at the same indentation level of two spaces after that dash.
#
# DO use [[ ]] in conditions, so `>` is greater (not redirect) and $X is "$X"
# http://mywiki.wooledge.org/BashFAQ/031
#
# DON'T put variable *values* in quotes that don't need it (FOO=x not FOO="x")
# DO put variable *substitutions* in quotes ("$X" not $X), EXCEPT in [[ ]]
# https://unix.stackexchange.com/q/131766/
#
# DON'T use curly braces on variables unless needed ("$FOO" not "${FOO}")
# https://unix.stackexchange.com/a/4910
#
# DO use = in [[ ]] conditions for lexical comparison (= not ==)
# https://unix.stackexchange.com/a/16110
#
# DON'T put space between x=y when doing variable assignments (you can't! :-/)
# https://unix.stackexchange.com/a/297217
#
# DON'T use superfluous semicolons at end of lines of shell commands:
# https://stackoverflow.com/a/7507242/
#
# DO use $(...) vs. `...` for shell execution (save `...` for code comments)
# https://stackoverflow.com/a/9406350/
#
# "$foo 123" -> substitutes foo contents to get `foocontents 123`
# '$foo 123' -> takes it literally, so you get `$foo 123`
#
# `xargs` may be a useful command when dealing with the shell:
# http://man7.org/linux/man-pages/man1/xargs.1.html  (e.g. `... | xargs cat`)
#

# When doing cross-compilation, the build products can't be examined using the
# normal tools on the host.  The tools in $CROSS_DIR need to be used, e.g.:
#
#    if [[ $OS_ID = 0.3.1 ]]; then  # x86-win32
#        "${CROSS_PREFIX}objdump" -t lib/i386/alloca86.o | grep alloca
#    elif [[ $OS_ID = 0.3.40 ]]; then
#        "${CROSS_PREFIX}objdump" -t lib/x86_64/alloca86_64.o | grep alloca
#    fi
#


notifications:
  email: false  # committers are keeping an eye on failures, supposedly!


# Travis defaults to 50; not needed, use 3 (just 1 affects queue notification)
#
# https://docs.travis-ci.com/user/customizing-the-build/#git-clone-depth
#
git:
  depth: 3


# Each configured travis instance has its own customized environment variables
# to give it unique behavior.  But there are also global environment keys,
# available to the overall Travis process itself (e.g. deployment)
#
# https://docs.travis-ci.com/user/environment-variables/#Global-Variables
#
env:
  global:
    #
    # This script deploys the build products to s3, but does not use the
    # `deploy` feature of Travis.  It instead uses the `aws` command-line tool
    # in order to get more fine-grained control on what MIME types the files
    # have, as well as to specify the order in which files are uploaded.
    #
    # YOU MAY SEE ERRORS ON SECURE VARIABLES IF NOT ON THE MAIN REPOSITORY!
    #
    # e.g. "The previous command failed, possibly due to a malformed secure
    # environment variable."
    #
    # https://stackoverflow.com/q/42525861/how-to-encrypt-your-travis-keys
    #
    # The entries labeled "secure" are encrypted environment variables, which
    # are tailored to the main repo.  If you're browsing logs on Travis for
    # a pull request building against your own repo, you might see:

    # To create this secured variable:
    #     `travis encrypt AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID`
    #
    - secure: 'Bex3tqrlsnv+t3+AJu6nG8bcbfHXeBNWIUUdcEeyB8gWnWnVuBsC5hTw9cUhEWJchJSsV4LeWVL51harzOQRntszyfjeNvPQozCXbTQVGd1tn5Rpt1QKN9VBK007c+ERj9L8JzFkM2HdeVusYY4Bz5tI883DSJkydyJpJp21mG9i8a17bqJsgBW0JmMsMsdv1ilaeb8/Luo8bn0ObIWTTz+4/6RF4XU9UcWLH7I4HlGb3qufR9chWCX7jTT0SLRkEgfudr+KVrY4xIspiPlVwrKvagnOTFcYLxN4JpGOgn1rnCcOxsWo4kE4dwgXZvEn8W2HJmJhzhAHDLkF0S7YhIDQaScJLwSVECI9xu68V5siWdyhzyrSb2K7V8Mtzryjzq1QueCrRRTj7XLY7sx5OxeP//RVMY0Poil5DdB84nI1wezzmT1kj7dkc1Fr1ZqdYSEfCZNd1v+DeRmAf/N70xUyx1tSxAHD96kjDM3lGILIrlt9RLWdeT0BqxQxzaKCowPVgfztH0nzPcoe1DfNfIhG9mEdjeJfLC7hAgc9Dn0KTo/oSwX/TBsTavV+6SPxH1D4q1xVdY9p4G2hS/N1xaqf7ys4DQOPwWZwvhujwGtto4fy7VMvDtX7jI6++0dJe+baG0DetlHvUGKzWpBJgk02k3mREH+9Ui8f7T9vn8Y='

    # To create this secured variable:
    #     `travis encrypt AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY`
    #
    - secure: 'IlBRG9mRM0BDtb9ZJDKl4QVRjs/e3KxvjEdVS9e8+PlGq+xMDVGQdje9WOED/bhTcoAYabhLKkXY8YZg6rlVj4ecyjjmZRfPA4D9YVMVHZVNldLX9Ed79Kv95dTvFdn6xl9Tbk/CEqtxfDwcN2hZqv9M3TXN2+sKzny6p4ENc8O7sz0Stb4GyFgPdWSIs4SZv/r8/feMgWiUx+q1NFFarMmFsLtKVuiPIyoU6fGW1zZPyh10jKuhi9GYBStcMHIWqvU+9+jbqchMJT1t/1fyEf0fJokNMH2KXCVDbsu7nKhaVZbIxirLdZNicKfzype1uRgzAB/Crpup+TwnINd17HPSqjCnqntuS+pO0mIRcXVhNSE8TG9S8x4N0pgtKYHKyfAjElmjLwPfoMhu5VlZishn6heeUALbQ7y44YwWwG8EoW4PnRFIGg7V4EjlHJkcmDhJWrZX2hVvSGJ72lFhHXFMcr+VKhXWlmK97XdFAz/c/LlSyyrmKtIE6W5kwhJC8bbrpETA/wQ9pP3WEVY28bka24LqI1g0hiDn7cyXae7Ikss36Y8eB/9/00EovCPHw1o+dyenXI10Q8+yorQ42xrjo1bXuYRohCvI+FmV4XFLkJ+c6wDTSKhJTcUhZsQva2F0ipeyqhGQQGkLiZ8BvdoSPHHBx2odikgho9VQZ48='
 
    - AWS_S3_BUCKET_NAME: 'metaeducation'

    # Address Sanitizer output needs to be "symbolized" to get symbols and
    # line numbers.  This option must be set along with ASAN_SYMBOLIZER_PATH.
    # However, some modern gcc and clang will figure it out even if there is
    # no path set, so go ahead and set this for all the build environments.
    #
    - ASAN_OPTIONS='symbolize=1'


# All Travis instances in the following "matrix" will run the same `script:`
# code (found later on in the file).  However, each instance has environment
# variables which can guide that script to behave differently.
#
matrix:
  include:
    - name: "[1] WebAssembly w/pthreads, release"
      #
      # The job of this build is to create a JavaScript library that can be
      # loaded into a web page or Node.JS.  For an example:
      #
      # https://github.com/hostilefork/replpad-js
      #
      os: linux
      dist: bionic  # Trying instead of xenial to check Firefox Marionette
      language: c
      env:
        - NUMBER=1
        - CONFIG=emscripten.r
        - OS_ID=0.16.2
        - DEBUG=none
        - OPTIMIZE=z
        - STANDARD=c
        - RIGOROUS=no
        - STATIC=no
        - WITH_FFI=no
        - ODBC_REQUIRES_LTDL=no
        - EXTENSIONS=-  # requests inclusion of no extensions (default?)
        - FF_SHARED_MEMORY=true
      addons:
        apt:
          packages:
            - net-tools  # for netstat/etc. diagnosing network issues

    - name: "[2] WebAssembly no pthreads, release"
      #
      # Asyncify is a less-desirable way to achieve asynchronous code in a
      # browser than using WebAssembly Threads.  However, some JavaScript
      # hosts are missing that--or other features--which are needed for the
      # "good" emscripten build.  (Alternatively they may have the features,
      # but disable them by default, creating a usability barrier.)
      #
      # https://emscripten.org/docs/porting/asyncify.html
      #
      # This build varation is created as a fallback.
      #
      os: linux
      dist: xenial  # Travis recommended distribution as of Mar-2020
      language: c
      env:
        - NUMBER=2
        - CONFIG=asyncify.r
        - OS_ID=0.16.1
        - DEBUG=none
        - OPTIMIZE=z
        - STANDARD=c
        - RIGOROUS=no
        - STATIC=no
        - WITH_FFI=no
        - ODBC_REQUIRES_LTDL=no
        - EXTENSIONS=-  # requests inclusion of no extensions (default?)
        - FF_SHARED_MEMORY=false
      addons:
        apt:
          packages:
            - net-tools  # for netstat/etc. diagnosing network issues

    - name: "[3] OSX x64, debug, clang++"
      #
      # !!! Can't do all warnings as errors, because in clang the switch for
      # files that end in .c as c++ ("-x c++") is deprecated for some overly
      # prescriptive and annoying reason.
      #
      os: osx
      osx_image: xcode8.3  # try an older XCode (on OS X 10.12)
      language: cpp
      env:
        - NUMBER=3
        - CONFIG=generic-c++.r
        - OS_ID=0.2.40
        - DEBUG=asserts
        - STANDARD=c++11
        - RIGOROUS=no
        - STATIC=no  # static linking switch not honored
        - WITH_FFI=dynamic
        - ODBC_REQUIRES_LTDL=no
        - EXTENSIONS="ODBC + ZeroMQ +"
        - BREW=yes
      # libraries (ODBC, ZeroMQ...) added via brew in `install` step below
      # Note: TCC extension has not been implemented for Mac

    - name: "[4] OSX x64, release, clang++"
      #
      # Note that this build is a *release* C++ build (the only one currently
      # on Travis).  This exercises the cast macros which create template
      # code, which are disabled in debug builds:
      #
      # http://blog.hostilefork.com/c-casts-for-the-masses/
      #
      # They are disabled because casting is done frequently, and when these
      # templates aren't inlined due to debugging they slow things down and
      # are very irritating to debug.  The syntax of `cast(type, expression)`
      # is however desirable to use pervasively.  So it's good to exercise
      # them in at least one build.
      #
      os: osx
      osx_image: xcode9.1  # try a newer XCode (on OS X 10.12)
      language: cpp
      env:
        - NUMBER=4
        - CONFIG=generic-c++.r
        - OS_ID=0.2.40
        - DEBUG=none  # see notes, release C++ exercises cast() macros
        - STANDARD=c++14
        - RIGOROUS=no
        - STATIC=no  # static linking switch not honored
        - WITH_FFI=no  # no FFI in this build
        - ODBC_REQUIRES_LTDL=no
        - EXTENSIONS="ODBC + ZeroMQ +"
        - BREW=yes
      # libraries (ODBC, ZeroMQ...) added via brew in `install` step below

    - name: "[5] OSX x64, release, clang"
      #
      # This is the minimum bootstrap executable, built on the oldest image
      # (to get lowest common denominator library support).  To avoid dylib
      # dependencies on things like ODBC and ZeroMQ, it doesn't include them.
      #
      os: osx
      osx_image: xcode7.3  # try an older XCode and OS X image (OS X 10.11)
      language: c
      env:
        - NUMBER=5
        - CONFIG=generic.r
        - OS_ID=0.2.40
        - DEBUG=none
        - STANDARD=c
        - RIGOROUS=no
        - STATIC=no
        - WITH_FFI=no
        - ODBC_REQUIRES_LTDL=no
        - EXTENSIONS=""  # No ODBC or ZeroMQ in this build
        - BREW=no
       # The "Brew" OS X package installer appears to have stopped maintaining
       # their service on this older system.  It hangs.  So just don't use it.
       # Note: TCC extension has not been implemented for Mac

    - name: "[6] Linux x86, release, gcc"
      #
      # 32-bit Release Linux Build
      #
      # Travis-CI does not offer 32-bit containers, and 32-bit builds are
      # being phased out on desktop and server platforms in general.  But they
      # are common on embedded systems for the foreseeable future.  So though
      # cross-compiling and debugging is painful (in part because so many
      # fewer people do it that updates and testing lag on these toolchains).
      # we do it anyway.
      #
      # !!! Optimized builds with the version of the toolchain on Xenial seem
      # to have strange bugs with inlining, that disappear when you inline the
      # code manually.  Investigation suggests no violation of the C standard
      # on Ren-C's part, and upgrading to bionic appears to resolve the issue.
      #
      os: linux
      dist: bionic  # Xenial cross-compile toolchain seems to have inline bug
      sudo: required  # "containers will be retired soon"
      language: c
      env:
        - NUMBER=6
        - CONFIG=generic.r
        - OS_ID=0.4.4
        - DEBUG=symbols  # needed for Valgrind to give meaningful stacks
        - STANDARD=gnu89  # Note: ZeroMQ extension needs C99 or C++11
        - RIGOROUS=yes
        - STATIC=yes
        - TCC=i386-tcc
        - ARCH_CFLAGS=-m32
        - WITH_FFI=no
        - EXTENSIONS="Signal + TCC +"
        - RUNNER="valgrind --track-origins=yes"
        # 32-bit version does not have ODBC or ZeroMQ
      addons:
        apt:
          packages:
            - gcc-multilib
            - valgrind  # helpful since there's no ASAN for better crashes
            - libc-dbg:i386  # needed for valgrind on 32-bit
            # - unixodbc-dev:i386 # for ODBC extension; stopped installing
            # - libzmq3-dev:i386 # ZeroMQ:i386 stopped installing in Nov-2018
            - texinfo  # for makeinfo, required to build FFI
            # Note: Must build its own TCC for the TCC extension to work

    - name: "[7] Linux x64, debug, g++"
      #
      # !!! Note this distribution does not support c++11 completely, it's an
      # old gcc 4.6
      #
      # !!! This is currently the only build that supports FFI, due to the
      # convenience of `-lffi` on this platform for getting the library.  It
      # would take simprovements to Rebmake getting the right build switches
      # and libraries for the other platform...but the groundwork is still
      # here in the Travis file for that.
      #
      # https://forum.rebol.info/t/ffi-updates-and-notes/1201
      #
      os: linux
      dist: trusty  # Note: released in 2013
      sudo: false  # force new container-based infrastructure.
      language: cpp
      env:
        - NUMBER=7
        - CONFIG=generic-c++.r
        - OS_ID=0.4.40
        - DEBUG=asserts
        - STANDARD=c++0x
        - RIGOROUS=yes
        - STATIC=yes
        - TCC=tcc
        - ARCH_CFLAGS=
        - WITH_FFI=dynamic  # see note about being only build w/FFI for now
        - ODBC_REQUIRES_LTDL=no
        - EXTENSIONS="ODBC + ZeroMQ + TCC + Signal + FFI +"
        - ASAN_SYMBOLIZER_PATH=/usr/bin/llvm-symbolizer-3.4
        - ASAN_OPTIONS=symbolize=1
      addons:
        apt:
          packages:
            # - g++-multilib # why would this be necessary?
            - unixodbc-dev  # for ODBC extension
            - libzmq3-dev  # for ZeroMQ extension
            - texinfo  # for makeinfo, required to build FFI
            #
            # !!! In theory we should be able to use the stock tcc here.
            # In practice, there's something wrong with the variadics in
            # this old Linux.  So we have to build a newer tcc ourselves
            #
            #- libtcc-dev  # for being able to `-ltcc` for compilation API
            #- tcc  # tcc executable (unused), but gets libtcc1.a + tcc headers
            - libffi-dev

    - name: "[8] Linux x64, release, gcc"
      #
      # We try to create a bare-minimum Linux executable for bootstrap.  This
      # has the least dependencies and run on the oldest systems.
      #
      # Note that this uses the older "precise" distribution, instead of the
      # new default of "trusty".  In addition to providing some more build
      # variations for testing, `libltdl-dev:i386` won't install on trusty.
      # (also, gcc on Ubuntu 12.04 does not support sanitizers)
      #
      os: linux
      dist: precise # old release (for lowest-common-denominator glibc)
      sudo: false # force new container-based infrastructure
      language: c
      env:
        - NUMBER=8
        - CONFIG=generic.r
        - OS_ID=0.4.40
        - DEBUG=none
        - STANDARD=gnu99
        - RIGOROUS=yes
        - STATIC=yes
        - WITH_FFI=no
        - EXTENSIONS="Signal +"
        # no ODBC, ZeroMQ, FFI dependencies
      addons:
        apt:
          packages:
            - gcc-multilib  # !!! what was this for?

    - name: "[9] Windows x86, release, gcc"
      #
      # !!! There was an issue where TCC caused a panic on startup for this
      # configuration.  It should be tested to see if that has been fixed.
      #
      # https://github.com/metaeducation/ren-c/issues/603
      #
      os: linux
      sudo: false # force new container-based infrastructure.
      language: c
      env:
        - NUMBER=9
        - CONFIG=mingw-x86.r
        - OS_ID=0.3.1
        - DEBUG=none
        - CROSS_PREFIX=i686-w64-mingw32-  # trailing hyphen is intentional
        - STANDARD=c
        - RIGOROUS=yes
        - STATIC=yes
        - TCC=i386-win32-tcc
        - HOST=i686-w64-mingw32
        - ARCH_CFLAGS=-m32
        - WITH_FFI=no  # was "dynamic"
        - ODBC_REQUIRES_LTDL=no
        - EXTENSIONS="ODBC + Clipboard + TCC +"
      addons:
        apt:
          packages:
            - binutils-mingw-w64-i686
            - gcc-mingw-w64-i686
            - mingw-w64
            - texinfo  # for makeinfo, required to build FFI
            # Note: Must build its own TCC for the TCC extension to work

    - name: "[10] Windows x64, debug, gcc"
      #
      # Linux cross-compilation to 64-bit Windows
      #
      os: linux
      sudo: false  # force new container-based infrastructure.
      language: c
      env:
        - NUMBER=10
        - CONFIG=mingw-x64.r
        - OS_ID=0.3.40
        - DEBUG=asserts
        - CROSS_PREFIX=x86_64-w64-mingw32-  # trailing hyphen is intentional
        - STANDARD=c
        - RIGOROUS=yes
        - STATIC=yes
        - TCC=x86_64-win32-tcc
        - HOST=x86_64-w64-mingw32
        - WITH_FFI=no  # was "dynamic"
        - ODBC_REQUIRES_LTDL=no
        - EXTENSIONS="ODBC + Clipboard + TCC +"
      addons:
        apt:
          packages:
            - binutils-mingw-w64-i686
            - gcc-mingw-w64-i686
            - mingw-w64
            # Note: Must build its own TCC for the TCC extension to work

    - name: "[11] Windows x64, debug, g++"
      #
      # There is an issue where if you do a C++ build on this toolchain in the
      # "precise" image, that newer MinGW will give an EXE with a superfluous
      # dependency on the pthread MinGW DLL.  It could be dealt with many
      # ways, but just use the "trusty" image for now because it is easier.
      #
      # https://github.com/metaeducation/ren-c/issues/624
      #
      # !!! Note this distribution does not support c++11 or above
      #
      os: linux
      dist: trusty  # see note above
      sudo: false  # force new container-based infrastructure
      language: cpp
      env:
        - NUMBER=11
        - CONFIG=mingw-x64-c++.r
        - OS_ID=0.3.40
        - DEBUG=asserts
        - CROSS_PREFIX=x86_64-w64-mingw32-  # trailing hyphen is intentional
        - STANDARD=c++11  # was C++98 but C++11 needed for variadic macro ODBC
        - RIGOROUS=yes
        - STATIC=yes
        - TCC=x86_64-win32-tcc
        - HOST=x86_64-w64-mingw32
        - WITH_FFI=no  # was `dynamic`
        - ODBC_REQUIRES_LTDL=no
        - EXTENSIONS="ODBC + Clipboard + TCC +"
      addons:
        apt:
          packages:
            - binutils-mingw-w64-x86-64
            - g++-mingw-w64-x86-64
            - mingw-w64
            # Note: Must build its own tcc version

    - name: "[12] Android5, debug, gcc"
      #
      # Debug Android build
      #
      os: linux
      dist: trusty
      sudo: false  # force new container-based infrastructure
      language: c
      env:
        - NUMBER=12
        - CONFIG=android5-arm.r
        - OS_ID=0.13.2
        - DEBUG=asserts
        - STANDARD=c
        - RIGOROUS=yes
        - STATIC=yes
        - HOST=arm-eabi
        - WITH_FFI=no
        - ODBC_REQUIRES_LTDL=no
        - EXTENSIONS=""

    - name: "[13] Android5, release, gcc"
      #
      # Release Android build
      #
      os: linux
      dist: trusty
      sudo: false  # force new container-based infrastructure
      language: c
      env:
        - NUMBER=13
        - CONFIG=android5-arm.r
        - OS_ID=0.13.2
        - DEBUG=none
        - STANDARD=c
        - RIGOROUS=yes
        - STATIC=yes
        - HOST=arm-eabi
        - WITH_FFI=no
        - ODBC_REQUIRES_LTDL=no
        - EXTENSIONS="TCC +"
        - TCC=arm-tcc
        - NEEDS_FAKE_STRTOLD=1  # strtold() workaround: https://tinycc-devel.nongnu.narkive.com/MZBcPTBN/problem-compiling-tinycc-for-android-strtold
        - ARCH_CFLAGS="-DANDROID -DTCC_ARM_EABI -DTCC_ARM_VFP -DTCC_ARM_HARDFLOAT"
      addons:
        apt:
          packages:
            - gcc-multilib  # for cross-compiling


# The install step occurs before the `script:` step runs.  The language that
# was specified in the `matrix:` entry for each instance will guide certain
# default tools that will be installed.  But you can add custom steps:
#
# https://docs.travis-ci.com/user/customizing-the-build#Customizing-the-Installation-Step
#
# In our case, we'd like to fetch a Rebol binary to use as the "r3-make".
# Its job is to process C and Rebol sources to automatically generate some
# header files and embedded Rebol code bundles used in bootstrap, as well as
# to generate makefiles.
#
# !!! Originally, the Rebol that was fetched was the last r3-alpha that was
# published on rebol.com, to ensure that it could still be used for bootstrap.
# Conversion of the build in mid-2017 to using %rebmake.r meant that only a
# semi-recent Ren-C could be used to run the build prep steps.  There will not
# be an attempt to go back to building with R3-Alpha, though a more purposeful
# stable build should be picked at some point to replace the ad-hoc choice
# which wound up in the make dir.  The shim which is required to upgrade that
# older Ren-C is now rather "thick", and slows the build down significantly.
#
install:
  - export PREBUILT="$(pwd)/prebuilt"  # see README.md in %prebuilt/ directory

  # If we do two builds, we use the bootstrap executable for the first and the
  # resulting Rebol from that build to do the second.  To keep from making
  # mistakes and accidentally using the wrong r3-make, the executables are
  # named `r3-one` and `r3-two`.  (If we only do one build, then r3-one will
  # just get renamed to r3-two.)
  - |
    if [[ $TRAVIS_OS_NAME = linux ]]; then
      wget -O "${PREBUILT}/r3-one" https://s3.amazonaws.com/r3bootstraps/r3-linux-x64-8994d23
    elif [[ $TRAVIS_OS_NAME = osx ]]; then
      #
      # Brew was being installed even on minimal release builds, making it
      # unnoticed that there was a .dylib dependency from the bootstrap
      # release executable on ZeroMQ and ODBC.  This old debug build was
      # captured at the same version number as the bootstrap executables.
      # Use it for now until the next capture for the old OS X.
      #
      wget -O "${PREBUILT}/r3-one" https://s3.amazonaws.com/r3bootstraps/r3-osx-x64-8994d23-debug
    else
      echo "!!! Unknown Travis Platform !!!"
      exit 1
    fi

  - chmod +x "${PREBUILT}/r3-one"  # make bootstrap Rebol tool executable

  - PATH="${PREBUILT}":$PATH  # so we can just say `r3-one` or `r3-two`

  # Install "Homebrew" package manager.  The Travis OS X images have brew
  # preinstalled, but get old and out of sync with the package database.
  # This means brew has to update.  It's supposed to do this automatically,
  # but circa 2017 it broke in some images due to the lack of a sufficiently
  # up-to-date Ruby:
  #
  # https://github.com/travis-ci/travis-ci/issues/8552
  - |
    if [[ $TRAVIS_OS_NAME = osx && $BREW = yes ]]; then
      #
      # But even if brew can update automatically, it generates an unsightly
      # amount of output if it does so during a `brew install`.  So redirect
      # the hundreds of lines to /dev/null to shorten the Travis log.
      #
      # https://github.com/Homebrew/legacy-homebrew/issues/35662
      #
      brew update > /dev/null

      brew install unixodbc  # for ODBC extension
      brew install zmq  # for ZeroMQ extension
    fi

  - |
    if [[ $OS_ID = 0.16.1 || $OS_ID = 0.16.2 ]]; then
      git clone --depth 1 https://github.com/emscripten-core/emsdk
      cd emsdk
      ./emsdk update-tags  # no `emsdk update` on git clone, use git pull

      # We use the latest incoming branch of emscripten (`tot-upstream`), not
      # the latest upstream release (`latest-upstream`) or the latest stable
      # release (`latest`).  While this is a more volatile choice, it helps
      # find out about potential problems faster...and make use of patches
      # that are applied to address our issues as soon as they are available.
      #
      ./emsdk install tot-upstream
      ./emsdk activate tot-upstream

      source emsdk_env.sh  # `source` => "inherit the environment variables"
      cd ..
    fi

    # Check for Python install utility ("PIP").  This is required to get the
    # Amazon Web Services command-line tool.  We only use the most basic
    # installation feature, so any version of pip should suffice.
  - |
    if ( pip3 --version ); then
      PIP=pip3
    elif ( pip2 --version ); then
      PIP=pip2
    elif ( pip --version ); then
      PIP=pip
    else
      echo "!!! NO VERSION OF PYTHON INSTALLER (PIP) FOUND !!!"
      exit 1
    fi
    echo "PIP=$PIP"

    # Install the AWS command-line tool for uploading to s3 (which we use
    # instead of Travis's `deploy`)
  - |
    if ( $PIP install awscli --upgrade --user ); then
        echo "AWS installed"
    else
        echo "!!! AWS not installed !!!"
        exit 1
    fi
    if ( aws --version ); then
      AWS=aws  # it was in the path
    else
      AWS="$(find /Users/travis/Library/Python/ -name aws)"  # look for it
      if ( ! $AWS --version ); then
        echo "!!! AMAZON WEB SERVICE UPLOAD TOOL (AWS) NOT FOUND !!!"
        exit 1
      fi
    fi
    echo "AWS=$AWS"

script:
      # whatever home directory Travis put us in, build there
    - |
      TOP_DIR="$(pwd)"  # https://stackoverflow.com/a/10795195/

    - |
      "${CROSS_PREFIX}gcc" --version  # Output version of gcc for the log

    # Ask for as many parallel builds as the virtual host supports
    - |
      if [[ $TRAVIS_OS_NAME = linux ]]; then
        export MAKE_JOBS="$(nproc)"
      fi
      if [[ $TRAVIS_OS_NAME = osx ]]; then
        export MAKE_JOBS="$(sysctl -n hw.ncpu)"
      fi

    # Native Development Kit (NDK) is for C/C++ cross-compilation to Android.
    # https://developer.android.com/ndk
    # @giuliolunati is the maintainer and active user of the Android build.
    - |
      if [[ $OS_ID = 0.13.2 ]]; then
          if [[ $(uname -m) = x86_64 ]]; then
              wget https://github.com/giuliolunati/android-travis/releases/download/v1.0.0/android-ndk-r13.tgz
              export ANDROID_NDK="${TOP_DIR}/android-ndk-r13"
          else
              exit 1
          fi
          tar zxf android-ndk-r13.tgz
          echo "$(pwd)"
          ls -dl "$(pwd)/android-ndk-r13"
          export CROSS_PREFIX="${ANDROID_NDK}/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64/bin/arm-linux-androideabi-"
          export SYSROOT="${ANDROID_NDK}/platforms/android-19/arch-arm"
      fi

    # @ShixinZeng added pre-built FFI libraries that are compatible with the
    # MinGW cross-compiler and committed them to the git repository, because
    # that was apparently easier/faster than trying to build it here
    #
    # !!! Review making this use the package manager's libffi if possible
    - |
      if [[ $OS_ID = 0.3.40 || $OS_ID = 0.3.1 ]]; then  # Win32/Win64
          if [[ $OS_ID = 0.3.40 ]]; then
              export PKG_CONFIG_PATH="${TOP_DIR}/extensions/ffi/ffi-prebuilt/lib64/pkgconfig"
          else
              export PKG_CONFIG_PATH="${TOP_DIR}/extensions/ffi/ffi-prebuilt/lib32/pkgconfig"
          fi

          # Check cflags and libs
          # ("--define-prefix would be better, but it is not recognized")
          #
          pkg-config --define-variable="prefix=\"${TOP_DIR}/extensions/ffi/ffi-prebuilt\"" --cflags libffi
          pkg-config --define-variable="prefix=\"${TOP_DIR}/extensions/ffi/ffi-prebuilt\"" --libs libffi
      fi

    # Linux needs to build FFI if it is cross-compiling to 32-bit.  It's not
    # clear why it wouldn't use the `sudo apt get` FFI packages of the distro
    # on 64-bit (other than to use a consistent version committed in the repo)
    - |
      if [[ -z $WITH_FFI || $WITH_FFI != no ]]; then
          mkdir ffi-build
          cd external/libffi
          ./autogen.sh
          cd "${TOP_DIR}/ffi-build"
          if [[ -z $HOST ]]; then
              "${TOP_DIR}/external/libffi/configure" --prefix="$(pwd)/fakeroot" CFLAGS="$ARCH_CFLAGS"
          else #cross-compiling
              "${TOP_DIR}/external/libffi/configure" --prefix="$(pwd)/fakeroot" --host="$HOST"
          fi
          make -j "$MAKE_JOBS"
          make install
          export PKG_CONFIG_PATH="$(pwd)/fakeroot/lib/pkgconfig"
          # check cflags and libs
          pkg-config --cflags libffi
          pkg-config --libs libffi

          ls "$(pkg-config --variable=toolexeclibdir libffi)"

          #remove dynamic libraries to force it to link with static libraries
          rm -f "$(pkg-config --variable=toolexeclibdir libffi)/*.so*"
          rm -f "$(pkg-config --variable=toolexeclibdir libffi)/*.dylib*"
          rm -f "$(pkg-config --variable=toolexeclibdir libffi)/*.dll*"
          
          ls "$(pkg-config --variable=toolexeclibdir libffi)"

          echo "FFI builds are erroring for now, above command fails"
          echo "Revisit when time permits - not currently being used"
      fi

    - mkdir "${TOP_DIR}/build"
    - cd "${TOP_DIR}/build"

    # For building the TCC extension, it requires both the TCC library (API
    # you can link in to pass a string of code and compile it), as well as
    # runtime support for that code once compiled.  See TCC extension README.
    #
    # While Fabrice Bellard is not involved in TCC development any longer,
    # others are maintaining it.  Modifications have been proposed which would
    # make the "Standalone Building" feature for Rebol better:
    #
    # http://lists.nongnu.org/archive/html/tinycc-devel/2018-12/msg00011.html
    #
    # But given priorities, there are not enough Rebol dev resources to
    # develop and maintain a separate fork of TCC for that.
    #
    - |
      if [[ ! -z $TCC ]]; then
          if [[ 0 = 1 ]]; then
              #
              # !!! What's a better representation for literal false in bash?
              #
              # !!! was if [[ $OS_ID == 0.4.40 ]], but the old trusty doesn't
              # have working variadics in its stock libtcc)
              #
              # ---
              #
              # Just use the tcc and libtcc installed by the package manager
              # (in the matrix settings above).  That's because the platform
              # the TCC inside Rebol will be compiling for after installation
              # on the user's machine is identical to the Travis container
              # doing the compilation.
              #
              # This directory may vary, find with `dpkg -L tcc`
              #
              # (export is so that if we run r3 to test tcc, it can see it)
              #
              export CONFIG_TCCDIR=/usr/lib/tcc  # no slash!
          else
              # If cross-compiling, we can't merely `sudo apt-get` the libtcc
              # and resources we need...have to build it from scratch.

              # By using `--depth=1` this gets the publicly updated *latest
              # commit only* (don't bother cloning the entire history)
              #
              git clone --depth=1 git://repo.or.cz/tinycc.git tcc

              # TCC has an %include/ directory at the top level of the build
              # (for the unix-style files) and tends to generate libtcc1.a in
              # the top-level directory also.  But if you're using Win32, you
              # want to set CONFIG_TCCDIR to the %win32/ subdir, which
              # contains a different %include/ as well as a %lib/ dir.
              #
              # (export is so that if we run r3 to test tcc, it can see it)
              cd tcc
              export CONFIG_TCCDIR="$(pwd)"

              # If you want a "tcc.exe" cross compiler, you could use
              # `./configure --enable-cross` and then `make`.  However, a TCC
              # executable is no longer needed to build the TCC extension.

              echo "Generating libtcc.a (provides the libtcc compilation API)"

              # libtcc.a requires --config-mingw32, or it doesn't think it's a
              # native compiler and disables functions in tccrun.c (including
              # the important `tcc_relocate()`
              #
              # !!! If the 64-bit tries to use `--config-mingw64`, then it
              # also doesn't define `TCC_IS_NATIVE` on windows, because it
              # seems `TCC_TARGET_PE` (Program Executable, e.g. Windows) is
              # only set by `--config-mingw32`.  Review.

              if [[ $OS_ID = 0.4.40 ]]; then
                  ./configure --cpu=x86_64 --enable-static --extra-cflags="$ARCH_CFLAGS" --extra-ldflags="$ARCH_CFLAGS"
              elif [[ $OS_ID = 0.4.4 ]]; then
                  ./configure --cpu=x86 --enable-static --extra-cflags="$ARCH_CFLAGS" --extra-ldflags="$ARCH_CFLAGS"
              elif [[ $OS_ID = 0.3.1 ]]; then  #x86-win32
                  ./configure --config-mingw32 --cpu=x86 --enable-static --extra-cflags="$ARCH_CFLAGS" --cross-prefix="$CROSS_PREFIX" --extra-ldflags="$ARCH_CFLAGS"
              elif [[ $OS_ID = 0.13.2 ]]; then  #arm-android5
                  ./configure --cpu=arm --enable-static --extra-cflags="$ARCH_CFLAGS --sysroot=\"$SYSROOT\"" --cross-prefix="$CROSS_PREFIX" --extra-ldflags="$ARCH_CFLAGS --sysroot=\"$SYSROOT\""
              else  #x86_64-win32, see note that --config-mingw32 vs. --config-mingw64 is intentional
                  ./configure --config-mingw32 --cpu=x86_64 --enable-static --extra-cflags="$ARCH_CFLAGS" --cross-prefix="$CROSS_PREFIX" --extra-ldflags="$ARCH_CFLAGS"
              fi
              make libtcc.a && cp libtcc.a libtcc.a.bak

              make clean

              # For the generation of %libtcc1.a, `--config-mingw32` must be
              # turned off, or it will try to compile with tcc.exe

              echo "Generating libtcc1.a (runtime lib for TCC-built programs)"

              if [[ $OS_ID = 0.4.40 ]]; then
                  ./configure --cpu=x86_64 --extra-cflags="$ARCH_CFLAGS" --extra-ldflags="$ARCH_CFLAGS"
              elif [[ $OS_ID = 0.4.4 ]]; then
                  ./configure --cpu=x86 --extra-cflags="$ARCH_CFLAGS" --extra-ldflags="$ARCH_CFLAGS"
              elif [[ $OS_ID = 0.3.1 ]]; then  # x86-win32
                  ./configure --cpu=x86 --extra-cflags="$ARCH_CFLAGS" --cross-prefix="$CROSS_PREFIX" --extra-ldflags="$ARCH_CFLAGS"
              elif [[ $OS_ID = 0.13.2 ]]; then  # arm-android5
                  ./configure --cpu=arm --extra-cflags="$ARCH_CFLAGS --sysroot=\"$SYSROOT\"" --cross-prefix="$CROSS_PREFIX"  --extra-ldflags="$ARCH_CFLAGS --sysroot=\"$SYSROOT\""
              else  # x86_64-win32
                  ./configure --cpu=x86_64 --extra-cflags="$ARCH_CFLAGS" --cross-prefix="$CROSS_PREFIX" --extra-ldflags="$ARCH_CFLAGS"
              fi

              echo "make libtcc1.a"
              # Note: Could fail to build tcc due to lack of '-ldl' on Windows
              make libtcc1.a XCC="${CROSS_PREFIX}gcc" XAR="${CROSS_PREFIX}ar" || echo "ignoring error in building libtcc1.a"
              cp bin/* .  # restore cross-compilers, libtcc1.a depends on tcc
              touch tcc  # update the timestamp so it won't be rebuilt
              echo "ls"
              ls  # take a look at files under current directory
              echo "make libtcc1.a"
              make libtcc1.a XCC="${CROSS_PREFIX}gcc" XAR="${CROSS_PREFIX}ar"
              "${CROSS_PREFIX}ar" d libtcc1.a armeabi.o  # avoid link conflict with libtcc.a

              #restore libtcc.a
              # make libtcc1.a could have generated a new libtcc.a
              cp libtcc.a.bak libtcc.a

              echo "Objdumping!"
              objdump -a libtcc.a
          fi
          make
          cd "${TOP_DIR}/build"
      fi

    # Grab the abbreviated and full git commit ID into environment variables.
    # The full commit is passed to make to build into the binary, and the
    # abbreviated commit is used to name the executable.
    #
    # http://stackoverflow.com/a/42549385/211160
    #
    - GIT_COMMIT="$(git show --format="%H" --no-patch)"
    - echo "$GIT_COMMIT"
    - GIT_COMMIT_SHORT="$(git show --format="%h" --no-patch)"
    - echo "$GIT_COMMIT_SHORT"

    # As an extra step to test bootstrap ability, if the build can be run on
    # the Travis we are using...make the debug build go even further by doing
    # another full build, but using the just built r3 as its own r3-make.
    # This will work on 64-bit OS X or Linux, and 32-bit if 32-bit support has
    # been installed
    #
    - |
      if [[ $DEBUG != none && ($OS_ID = 0.4.40 || $OS_ID = 0.4.4 || $OS_ID = 0.2.40) ]]; then
          #
          # If building twice, don't specify GIT_COMMIT for the first build.
          # This means there's a test of the build process when one is not
          # specified, in case something is broken about that.  (This is how
          # most people will build locally, so good to test it.)
          #
          # Also request address sanitizer to be used for the first build.  It
          # is very heavyweight and makes the executable *huge* and slow, so
          # we do not apply it to any of the binaries which are uploaded to s3
          # -- not even debug ones.
          #
          r3-one ../make.r CONFIG="../configs/${CONFIG}" TARGET=makefile STANDARD="$STANDARD" OS_ID="$OS_ID" RIGOROUS="$RIGOROUS" DEBUG=sanitize OPTIMIZE=2 STATIC=no ODBC_REQUIRES_LTDL="$ODBC_REQUIRES_LTDL" EXTENSIONS="$EXTENSIONS" $EXTRA
          make clean prep folders
          make -j "$MAKE_JOBS"

          # We have to set R3_MAKE explicitly to circumvent the automatic
          # r3-make filename inference, as we always use Linux "r3-two"
          # (not "r3-two.exe") even when doing windows builds, since this is
          # a cross-compilation.
          #
          mv r3 "${PREBUILT}/r3-two"
          rm "${PREBUILT}/r3-one"
          export R3_MAKE="${PREBUILT}/r3-two"

          # Now that we've moved the `r3` out of the way, try cleaning up the
          # other build products...and make sure it doesn't accidentally pick
          # up the old makefile.
          #
          make clean
          rm makefile

          # This instructs `r3-two` to use a mode in which allocations are not
          # pooled, but each uses an individual `malloc()`.  That means we
          # get the benefit of the checked/hooked allocator for address
          # sanitizer, which the pools don't have a parallel to at the moment.
          #
          export R3_ALWAYS_MALLOC=1

          # We'll do a simple HTTPS read test on the second build.  But on
          # this first build, we also do it because it has the address
          # sanitizer, which may catch more problems.
          #
          r3-two --do "print {Testing...} quit either find to-text read https://example.com {<h1>Example Domain</h1>} [0] [1]";
          R3_EXIT_STATUS=$?
          echo $R3_EXIT_STATUS
      else
        mv "${PREBUILT}/r3-one" "${PREBUILT}/r3-two"
      fi

    - |
      if [[ -z $TCC ]]; then
        export WITH_TCC=no
      else
        export WITH_TCC="%${PWD}/tcc/${TCC}"
      fi

    # On the second build of building twice, or just building once, include
    # the GIT_COMMIT
    #
    - r3-two ../make.r CONFIG="../configs/${CONFIG}" TARGET=makefile STANDARD="$STANDARD" OS_ID="$OS_ID" DEBUG="$DEBUG" GIT_COMMIT="{$GIT_COMMIT}" RIGOROUS="$RIGOROUS" STATIC="$STATIC" WITH_FFI="$WITH_FFI" WITH_TCC="$WITH_TCC" ODBC_REQUIRES_LTDL="$ODBC_REQUIRES_LTDL" EXTENSIONS="$EXTENSIONS" $EXTRA

    # Do the main build of the files we will be uploading
    #
    - make clean prep folders
    - make -j "$MAKE_JOBS"

    # Dump out a list of the library dependencies of the executable
    - |
      if [[ $OS_ID = 0.4.40 || $OS_ID = 0.4.4 ]]; then
          ldd ./r3
      elif [[ $OS_ID = 0.2.40 ]]; then
          otool -L ./r3
      fi

    # Run once but don't pipe output, in case it prints out useful crash msg
    # that we want to see in the Travis log (especially helpful for failures
    # only happening in the Travis builds that aren't reproducing locally)
    # Save the exit code ($?) so we can return it to Travis as last step
    #
    # !!! This is a very minimal sanity check to ensure the built R3 does
    # *something*, and it can't be used on cross-compilations (e.g. a Windows
    # executable won't run on Linux).  Running the full test suite would be a
    # bit much, and developers are expected to have already done that.  But
    # doing an HTTPS read exercises a fair amount of code.
    #
    - |
      if [[ $OS_ID = 0.4.40 || $OS_ID = 0.4.4 || $OS_ID = 0.2.40 ]]; then
          $RUNNER ./r3 --do "print {Testing...} quit either find to-text read https://example.com {<h1>Example Domain</h1>} [0] [1]"
          R3_EXIT_STATUS=$?
      else
          R3_EXIT_STATUS=0
      fi
    - echo "$R3_EXIT_STATUS"

    # Run basic testing on FFI if it is included and this container can run it
    - |
      if [[ -z $WITH_FFI || $WITH_FFI != no ]]; then
        if [[ $OS_ID = 0.4.40 || $OS_ID = 0.4.4 ]]; then
          $RUNNER ./r3 ../tests/misc/qsort_r.r
          R3_EXIT_STATUS=$?
        else
          R3_EXIT_STATUS=0
        fi
      else
          R3_EXIT_STATUS=0
      fi
    - echo "$R3_EXIT_STATUS"

    # If the build is TCC-based and the host can run the produced executable,
    # do a simple test that does a TCC fibonnaci calculation.
    - |
      # The TCC extension currently looks at the environment variable
      # LIBREBOL_INCLUDE_DIR to find "rebol.h".  Ultimately, this should be
      # shipped with the TCC extension.  (It may be desirable to embed it,
      # but it also may be desirable to have a copy that a file can find
      # via `#include "rebol.h"`)
      #
      # (export is so that the child process can see the environment variable)
      #
      echo "Note: CONFIG_TCCDIR is ${CONFIG_TCCDIR}"
      export LIBREBOL_INCLUDE_DIR="${TOP_DIR}/build/prep/include"
      if [[ (! -z $TCC) && ($TCC != no) ]]; then
        if [[ $OS_ID = 0.4.40 ]]; then
          $RUNNER ./r3 ../tests/misc/fib.r
          R3_EXIT_STATUS=$?
        elif [[ $OS_ID = 0.4.4 ]]; then
          #
          # Most 32-bit builds are intending to run on 32-bit systems, hence
          # the running TCC should link to libs in `/usr/lib`.  But this
          # container is 64-bit (Travis does not support 32-bit containers,
          # nor do they seem to intend to).  The tcc extension heeds this
          # environment variable and uses hardcoded output of `gcc -v m32`
          # for library directories to override `/usr/lib` with.
          #
          export REBOL_TCC_EXTENSION_32BIT_ON_64BIT=1
          $RUNNER ./r3 ../tests/misc/fib.r
          R3_EXIT_STATUS=$?
        fi
      else
          R3_EXIT_STATUS=0
      fi
      echo $R3_EXIT_STATUS

    - |
      if [[ $R3_EXIT_STATUS != 0 ]]; then
        exit $R3_EXIT_STATUS
      fi

# DEPLOY STEP:

    # !!! This used to delete things because otherwise they would be uploaded
    # to s3 along with the whole build directory.  It doesn't really matter
    # now, because we are specific about what we upload using the aws tool.
    # It still might be desirable to delete things...
    #
    - rm -rf objs
    - rm -f makefile*
    - rm -f Toolchain*
    - rm -f r3-make*  # `-f` for success even when r3-make* doesn't exist

    # !!! When we *needed* to delete things, we would `- rm -rf tcc` and
    # `-rm -rf prep` here.  But we don't right now, because we wait until the
    # end (below) to zip together `rebol.h` and the TCC runtime files that the
    # caller will need.  This is a temporary solution, and is evolving.

    # check what is left in the build directory...
    - ls

    # Name the executable based on the abbreviated commit, whether it is a
    # debug or release build, and if it was built using C++ or not.  Note that
    # the C++ debug builds have additional runtime checks in the debug
    # build...though there should not be any impact on the release build.
    # (Though there may be additional DLL dependencies regardless.)
    #
    # !!! All Ren-C stakeholders should be using debug builds at this time.  
    #
    # Note: -z tests if a variable is undefined
    #
    - NEW_NAME="r3"; NEW_NAME_WITH_COMMIT="r3-${GIT_COMMIT_SHORT}"
    - |
      if [[ $DEBUG != none ]]; then
          NEW_NAME+='-debug'
          NEW_NAME_WITH_COMMIT+='-debug'
      fi
    - |
      if [[ $STANDARD = c++ || $STANDARD = c++0x || $STANDARD = c++11 || $STANDARD = c++14 || $STANDARD = c++17 ]]; then
          NEW_NAME+='-cpp'
          NEW_NAME_WITH_COMMIT+='-cpp'
      fi
    - echo NEW_NAME="$NEW_NAME"
    - echo NEW_NAME_WITH_COMMIT="$NEW_NAME_WITH_COMMIT"

    # Move the executable into a directory based on its OS_ID platform.
    # This is because the deploy step is run for each OS and would
    # otherwise overwrite executables in the same location.
    #
    # Note: [[-e]] tests for "existence"
    #
    - mkdir "$OS_ID"
    - |
      # Windows builds end in .exe
      if [[ -e r3.exe ]]; then
          cp r3.exe "${OS_ID}/${NEW_NAME_WITH_COMMIT}.exe"
          mv r3.exe "${OS_ID}/${NEW_NAME}.exe"
      fi

      # Most other platforms have no suffix
      if [[ -e r3 ]]; then
          cp r3 "${OS_ID}/${NEW_NAME_WITH_COMMIT}"
          mv r3 "${OS_ID}/${NEW_NAME}"
      fi

      # All emscripten builds produce .js and .wasm
      if [[ -e libr3.js ]]; then
           cp libr3.js "${OS_ID}/lib${NEW_NAME_WITH_COMMIT}.js"
           mv libr3.js "${OS_ID}/lib${NEW_NAME}.js"
      fi
      if [[ -e libr3.wasm ]]; then
           cp libr3.wasm "${OS_ID}/lib${NEW_NAME_WITH_COMMIT}.wasm"
           mv libr3.wasm "${OS_ID}/lib${NEW_NAME}.wasm"
      fi

      # Only pthreads builds produce .js.mem and .worker.js
      if [[ -e libr3.js.mem ]]; then
           cp libr3.js.mem "${OS_ID}/lib${NEW_NAME_WITH_COMMIT}.js.mem"
           mv libr3.js.mem "${OS_ID}/lib${NEW_NAME}.js.mem"
      fi
      if [[ -e libr3.worker.js ]]; then
           cp libr3.worker.js "${OS_ID}/lib${NEW_NAME_WITH_COMMIT}.worker.js"
           mv libr3.worker.js "${OS_ID}/lib${NEW_NAME}.worker.js"
      fi

    # Ultimately we'd like extensions to have an easy standard way to encap
    # resources that they use, and the TCC extension could pack up %rebol.h
    # and %libtcc1.a, as well as other support files it needs right into the
    # executable in a zip format.  But for now, we just make a zip file and
    # those who want to use TCC compilation have to unpack that zip manually.
    #
    # Note: The script prints out a list of the files it stores.  If you unzip
    # it you should be able to use the containing directory as both the
    # CONFIG_TCCDIR and the LIBREBOL_INCLUDE_DIR path.
    #
    # !!! It should be able to be done with r3-make, but uses features of file
    # paths and zip compression that are only available in newer builds.
    # Temporarily grab a special build for this purpose.
    #
    - |
      if [[ ! -z $TCC ]]; then
        #
        # Temporary solution on top of temporary solution (should be on s3,
        # but can't upload there at the moment)
        #
        wget http://hostilefork.com/media/shared/prebuilt/r3-encap
        chmod +x ./r3-encap
        ./r3-encap "${TOP_DIR}/extensions/tcc/encap-tcc-resources.reb" OS_ID="${OS_ID}"
        mv tcc-encap.zip "${OS_ID}/${NEW_NAME_WITH_COMMIT}-tcc-encap.zip"
      fi

    # Web Browsers are picky about the MIME type of WebAssembly files.  If
    # it's not `application/wasm` then it complains.  The `deploy` upload
    # mechanic in Travis has no way to specify this property, so we use the
    # command-line `aws` tool to do the upload of the .wasm file.
    #
    # We also want to control the *order* in which files are uploaded, which
    # Travis's deploy does not support.  For how the keys are kept secure
    # despite publishing this upload script, see:
    #
    # http://stackoverflow.com/a/42547424/211160
    #
    # NOTE: This is only one Travis "step" because the `upload` function is
    # not shared across steps.  That's not necessarily a great reason to
    # do it this way; we'd prefer more of this to be done with Rebol scripts.
    #
    - |
      if [[ ${R3_EXIT_STATUS} != 0 ]]; then
        exit 0  # don't try to upload any files if the tests didn't work
      fi

      if [[ ${TRAVIS_REPO_SLUG} != "metaeducation/ren-c" ]]; then
        exit 0  # secret AWS credentials to upload are only for metaeducation
      fi

      if [[ ${TRAVIS_BRANCH} != "master" || ${TRAVIS_PULL_REQUEST} != "false" ]]; then
        exit 0  # only direct pushes of master branch considered for upload
      fi

      function upload {
        # Note that `;;` is specific to bash's `case`, unrelated to `;`
        case $1 in
          *.wasm) OPT_TYPE="--content-type application/wasm" ;;
          *) OPT_TYPE="" ;;
        esac
        rm -f _
        $AWS s3 cp $1 s3://${AWS_S3_BUCKET_NAME}/travis-builds/$1 $OPT_TYPE
        $AWS s3 cp s3://${AWS_S3_BUCKET_NAME}/travis-builds/$1 _
        if ( cmp $1 _ ); then
          echo === UPLOADED $1 ===
        else
          echo === UPLOAD $1 FAILED ===
          exit 1
        fi
      }

      for i in $OS_ID/*; do upload $i; done

      # Start out by defaulting that we will greenlight the build and bump
      # the commit check...but if the browser REPL deployment doesn't pass
      # a test, we will change our answer and keep serving users the previous
      # commit via the old %last-deploy.short-hash
      #
      export DONT_GREENLIGHT_BUILD=0

      # Esmcripten build: copy load-r3.js to travis-builds/
      # (not in subdir of 0.16.x because loader needs to pick between them)
      #
      # Note: This is a weak link in the test-before-deploy strategy.  Because
      # there's not a way to override the singular loader, a change must be
      # deployed before we can test any build (even a non-"greenlit" one).
      #
      if [[ $OS_ID = 0.16.1 || $OS_ID = 0.16.2 ]]; then
        cp ../extensions/javascript/load-r3.js .
        upload load-r3.js
      fi

      # Generally we want to run testing before deployment.  For native builds
      # it is expected that the committer runs them (it would be nice to have
      # the build farm check as well, but that hasn't been too much of a
      # problem).  But web builds breaking is.  So we want to check the
      # deployment before "green-lighting" the %last-deploy.short-hash
      #
      # We do this currently in the web builds with a "headless" Firefox (e.g.
      # no GUI Window), automated through the Python's `marionette_driver`:
      #
      # https://firefox-source-docs.mozilla.org/python/marionette_driver.html
      #
      # The Marionette httpd server for control exists only in Firefox (with
      # a default port 2828) and is only enabled if you use `-marionette`.
      #
      # https://vakila.github.io/blog/marionette-act-i-automation/
      #
      # Comparable-but-incompatible APIs to control running browsers exist for
      # Chrome and others.  The W3C's "WebDriver" initiative standardizes a
      # "ODBC for browser control" which translates a common API into calls
      # with plugins for each particular browser.  The layer is bulky and is
      # typically used with "Selenium" which is even bulkier.  To be lighter
      # we just use Python with raw Marionette (it is likely not difficult to
      # just use Rebol to send the http requests, also.)
      #
      # Long term we might have to do more than this simple test, but in the
      # 80/20 rule it's going to deliver on catching most of the breakages.
      #
      if [[ $OS_ID = 0.16.1 || $OS_ID = 0.16.2 ]]; then
        $PIP install marionette-driver --user  # Python Install Package

        # Create a Firefox profile in the current directory that we can tweak
        # (as finding the default one's auto-generated name is a pain)
        #
        firefox -headless -CreateProfile "ff-profile $(pwd)/ff-profile"

        ######################################################################
        #
        # !!! We'd like 0.16.1 to pass the pthread builds test by configuring
        # Firefox to use pthreads.  We can do the configuration--but right now
        # pthreads are not working in Firefox due to issues with headers:
        #
        # https://bugzilla.mozilla.org/show_bug.cgi?id=1586217
        # https://github.com/emscripten-core/emscripten/issues/10014
        #
        # Until that is sorted out, we're just going to have to hope that the
        # Asyncify build test is good enough to mark passing both builds.
        # So what we're really testing is if Firefox is downgrading the
        # build to Asyncify.  :-(  Chrome with pthreads will just need to be
        # hoped to work.
        #
        ######################################################################
        #
        export FF_SHARED_MEMORY=false

        # The way to set `about:config` flags in preferences is via %user.js
        #
        # https://askubuntu.com/a/313662/137769
        # http://kb.mozillazine.org/User.js_file
        #
        # Rebol's more optimal "Pthreads" web build requires shared memory
        # and WebAssembly threads, which Firefox does not enable by default
        # at time of writing (Mar-2020).  Hence the less-optimial "Asyncify"
        # build provides a fallback, and %load-r3.js detects which to use.
        #
        # Even if this default changes, explicitly setting the flag to `true`
        # for the Pthreads deployment test and `false` for the Asyncify test
        # gives the right coverage for the corresponding build.
        #
        # !!! See above comments about why we only test the 0.16.2 build
        # (non-pthreads) due to 0.16.1 not working in Firefox at the moment.
        #
        # The Marionette port for control defaults to 2828, and can be
        # overridden on the command line by `--marionette-port <port>`.  But
        # to show another place to set it, here's the profile setting.
        #
        # Unfortunately Travis and HereDoc aren't very compatible, so we use
        # plain ECHO instead to make our user.js file:
        #
        # https://en.wikipedia.org/wiki/Here_document#Unix_shells
        # https://travis-ci.community/t/2756
        {
            echo "user_pref(\"javascript.options.shared_memory\", ${FF_SHARED_MEMORY});"
            echo "user_pref(\"marionette.port\", 2828);"  # should be default
        } > $(pwd)/ff-profile/user.js

        # We keep the Python test script for the browser build in the GitHub
        # replpad-js repository.  Fetch it.
        #
        wget https://raw.githubusercontent.com/hostilefork/replpad-js/master/tests/test-repl-ff.py

        # Start Firefox headless with the marionette automation enabled
        # (the `&` starts it in the background)
        #
        firefox -headless --profile ff-profile -marionette  &
        sleep 5  # Give Firefox time to spin up (should be in cache now)

        echo "Running netstat -lntu: Marionette should be listening on 2828"
        netstat -lntu
        ps aux | grep firefox

        # Run the script.  The result will be 0 if the test was sucessful.
        # Note that we ask the REPL to be instantiated with the libr3.js we
        # just uploaded that has not been "greenlit" by uploading the
        # `last-deploy.short-hash`...so we must pass the current commit in
        # explicitly to be asked for in the URL.
        #
        python test-repl-ff.py --shorthash "${GIT_COMMIT_SHORT}"
        export DONT_GREENLIGHT_BUILD=$?  # captures last command exit code
      fi

      # Each ${OS_ID} directory contains several builds for recent commits.
      # Since they are served statically from S3, we don't have a query to
      # serve the most recent one that successfully built (based on a date
      # or other property).  So we write a file with a fixed name in that
      # directory to identify the last build...it can be obtained via a
      # CORS fetch() request.
      #
      # However, the upload might take a while...or fail part way through.
      # Hence, we make this the last file uploaded--so that when the browser
      # tries to fetch files for that ID, they'll all be there.
      #
      if (( $DONT_GREENLIGHT_BUILD != 0 )); then
        echo "=== DON'T GREENLIGHT BUILD! ==="
        exit 1
      else
        #
        # -n option to echo means "no newline at end" (it's not a "text file"
        # so there is no standard enforcing that it have one...and it's
        # easier in the client to not have it)
        #
        echo -n "${GIT_COMMIT_SHORT}" > ${OS_ID}/last-deploy.short-hash
        upload ${OS_ID}/last-deploy.short-hash
      fi


after_script:
  - sleep 3  # https://github.com/travis-ci/travis-ci/issues/6018
  - echo "== END OF TEST LOG (success) =="

after_failure:
  - sleep 3  # https://github.com/travis-ci/travis-ci/issues/6018
  - echo "== END OF TEST LOG (failure) =="


# vim: set et sw=2:
